+++
title = "CX Руководство: Не Упусти Возможность Создать Небольшое Текстовое Приключение"
tags = [
    "CX",
    "CX Tutorials",
    "Affordances"
]
bounty = 5
date = "2017-09-20"
categories = [
    "Tutorials",
]
+++

<!-- MarkdownTOC autolink="true" bracket="round" depth="2" -->

- [Введение](#introduction)
- [Архитектура «вызов-отклик»](#challenge-response-architecture)
- [Affordance System](#affordance-system)
- [Объекты](#objects)
- [Заключение](#conclusion)

<!-- /MarkdownTOC -->

# Введение

В данном руководстве представлена текстовая «игра» (когда пользователь не взаимодействует 
напрямую с программой и не может влиять на решения героя). Игра построена по 
принципу [«вызов-отклик»](#challenge-response-architecture). Что 
позволяет определить какие действия герой игры может 
предпринять. Полную версию исходного кода можно найти в 
[CX’s repository](https://github.com/skycoin/cx), файл *examples/text-based-adventure.cx*.

Игра представляет собой приключения путешественника, который пытается спастись от 
монстра (Между прочим, Хэллоуин на подходе). Если путешественнику 
удастся остаться невредимым на протяжении определенного количества часов (это всего 
лишь этап в *for*-цикле), монстр прекратит преследование. Пример 
сеанса приведен ниже:

```
Путешественник продолжает движение по тропинке, не обращая внимание на боль.
Появляется ревущий и рычащий монстр.
Взгляд наполняется храбростью и надеждой пережить еще одну ночь.
Путешественник выглядит наивным и даже глупым, но его следующее действие ошеломляет монстра. 
Север, юг, запад, восток. Любое направление подойдет 
пока монстр в раздумьях.
Ревущий и рычащий монстр подходит ближе.
Путешественник убегает, а трусость продлевает жизнь еще на один день.

Вы выжили.
```
Если путешественник принимает решение вступить в борьбу и его героические попытки 
проваливаются, игра заканчивается. Вот пример окончания игры:

```
Север, юг, запад, восток. Любое направление подойдет 
пока монстр в раздумьях.
Ревущий и рычащий монстр подходит ближе.
Взгляд наполняется храбростью и надеждой пережить еще одну ночь.
Но его поджидает неудача, и вдруг, путешествие подходит к концу.
	
Вы погибли.

Call's State:
flag:			true
nonAssign_32:		""

halt() Arguments:
0: "You died."

65: call to halt
```
Если Вы погибаете, появляется ошибка (заметьте, что это нормально, ведь 
обычно это наводит страх на программиста). 

# Архитектура «вызов-отклик»

При данной архитектуре, возникает вопрос, и разные агенты должны дать ответ  
(в данном случае, функции). Простой вопрос, 
который может быть задан: «Кто может быть исполнителем в данный момент?» и те 
функции, которым разрешено выполнение, ответят на запрос. 

Следующие прототипы функций предполагают действия, 
которые могут произойти с путешественником. 

```
func walk (flag bool) () {}
func noise (flag bool) () {}
func consider (flag bool) () {}
func chance (flag bool) () {}
func fightResult (flag bool) () {}
func theEnd (flag bool) () {}
```

# Affordance System

Другая функция должна скоординировать вызовы функций. В этом случае, 
CX’s affordance system используется, чтобы определить 
разрешено ли действие.  

```
yes := true
no := false

remArg("walk")
affExpr("walk", "yes|no", 0)
:tag walk;
walk(false)
```
В приведенном выше коде remArg () ищет выражение с тегом «walk» 
и удаляет его аргумент. Это необходимо для того, чтобы получить список 
аргументов, который может быть отправлен выражениям. Затем, affExpr() сообщает CX: 
«из всех аргументов, которые могут быть отправлены по walk, сообщаем можем ли 
использовать *yes* или *nо* в качестве аргументов, и применяем *0-й* вариант из 
списка возможных вариантов».

Представленная процедура применима ко всем действиям, 
во время прохожения. Для всех этих действий применяются следующие правила, 
для определения разрешена она или нет:

```
setClauses("
          aff(walk, yes, X, R) :- X = monster, R = false.
          aff(noise, yes, X, R) :- X = monster, R = false.

          aff(consider, yes, X, R) :- R = false.
          aff(chance, yes, X, R) :- R = false.
          aff(fightResult, yes, X, R) :- R = false.
          aff(theEnd, yes, X, R) :- R = false.

          aff(consider, yes, X, R) :- X = monster, R = true.
          aff(chance, yes, X, R) :- X = fight, R = true.
          aff(fightResult, yes, X, R) :- X = fight, R = true.
          aff(theEnd, yes, X, R) :- X = died, R = true.
        ")
```

Первое правило читается так: «Я буду поставлен в очередь исполнения, в случае если *yes* 
будет передан в качестве аргумента в функцию *walk*. В случае если представлен объект 
*monster*, то аргумент не учитывается.

Правила следующего блока (4 правила после первой пустой строки) 
говорят системе «никогда» не принимать yes аргумент. 
Мы хотим, чтобы это было поведением по умолчанию, 
хотя позже мы вполне сможем их переопределить. Это и производится 
в последних 4-х правилах. В общем, этот блок правил говорит CX 
принять *yes* в качестве аргумента, при условии, что конкретный объект присутствует в стеке.

# Объекты

Некоторые действия могут добавлять либо убирать объект из стека объектов. 
Например, где бы ни появлялось действие *noise*(шум), там появляется монстр, 
исполняется: *addObject(“monster”)*. Когда путешественник принимает решение бежать, 
а не драться, "монстр" как объект исчезает из стека объектов.

В случае выбора действия *chance*(шанс), монстр может дать 
путешественнику несколько секунд на раздумья, чтобы посмотреть, что он будет делать дальше. 
Чтобы воплотить это, необходимо убрать объект “fight” (бой) так как монстр еще не хочет начинать драться, 
но оставить объект "monster".

# Заключение

CX’s affordance system использует объекты и правила, чтобы принимать комплексные 
решения о том, как будет производиться фильтрация.

Используя объекты, мы можем решать какие из действий активировать. 
В этом примере мы рассмотрели небольшое количество действий, 
необходимых для процесса активации. На первый взгляд может показаться, 
что данная архитектура бесполезна. Тем не менее, 
можно установить более сложные правила, включающие в себя большее количество объектов. 
Одно правило может отвечать за активацию нескольких узлов в большой сети 
действий. В примере мы рассмотрели всего два аргумента *yes* и *no*; Мы можем ввести больше аргументов, 
а также действия, которые принимают разные типы аргументов, отличные от булевских значений.
