+++
title = "CX Руководство: Не Упусти Возможность Создать Небольшое Текстовое Приключение"
tags = [
    "CX",
    "CX Tutorials",
    "Affordances"
]
bounty = 5
date = "2017-09-20"
categories = [
    "Tutorials",
]
+++

<!-- MarkdownTOC autolink="true" bracket="round" depth="2" -->

- [Введение](#introduction)
- [Архитектура «вопрос-ответ»](#challenge-response-architecture)
- [Affordance System](#affordance-system)
- [Объекты](#objects)
- [Заключение](#conclusion)

<!-- /MarkdownTOC -->

# Введение

В данном руководстве представлена текстовая «игра» (когда пользователь не взаимодействует 
напрямую с программой и не может влиять на решения героя). Игра построена по 
принципу [«вопрос-ответ»](#challenge-response-architecture). Что 
позволяет определить какие действия герой игры может 
предпринять. Полную версию исходного кода можно найти в 
[CX’s repository](https://github.com/skycoin/cx), файл *examples/text-based-adventure.cx*.

Игра представляет собой приключения путешественника, который пытается спастись от 
монстра (Между прочим, Хэллоуин на подходе). Если путешественнику 
удастся остаться невредимым на протяжении определенного количества часов (это всего 
лишь этап в *for*-цикле), монстр прекратит преследование. Пример 
сеанса приведен ниже:

```
Путешественник продолжает движение по тропинке, не обращая внимание на боль.
Появляется ревущий и рычащий монстр.
Взгляд наполняется храбростью и надеждой пережить еще одну ночь.
Путешественник выглядит наивным и даже глупым, но его следующее действие ошеломляет монстра. 
Север, юг, запад, восток. Любое направление подойдет 
пока монстр в раздумьях.
Ревущий и рычащий монстр подходит ближе.
Путешественник убегает, а трусость продлевает жизнь еще на один день.

Вы выжили.
```
Если путешественник принимает решение вступить в борьбу и его героические попытки 
проваливаются, игра заканчивается. Вот пример окончания игры:

```
Север, юг, запад, восток. Любое направление подойдет 
пока монстр в раздумьях.
Ревущий и рычащий монстр подходит ближе.
Взгляд наполняется храбростью и надеждой пережить еще одну ночь.
Но его поджидает неудача, и вдруг, путешествие подходит к концу.
	
Вы погибли.

Call's State:
flag:			true
nonAssign_32:		""

halt() Arguments:
0: "You died."

65: call to halt
```
Если Вы погибаете, появляется ошибка (заметьте, что это нормально, ведь 
обычно это наводит страх на программиста). 

# Архитектура «вопрос-ответ»

При данной архитектуре, возникает вопрос, и разные агенты должны дать ответ 
на вопрос (в данном случае, функции). Простой вопрос, 
который может быть задан: «Кто может быть исполнителем в данный момент?» и те 
функции, которым разрешено выполнение, ответят на запрос. 

Следующие прототипы функций предполагают действия, 
которые могут произойти с путешественником. 

```
func walk (flag bool) () {}
func noise (flag bool) () {}
func consider (flag bool) () {}
func chance (flag bool) () {}
func fightResult (flag bool) () {}
func theEnd (flag bool) () {}
```

# Affordance System

Другая функция должна скоординировать вызовы функций. В этом случае, 
CX’s affordance system используется, чтобы определить разрешено ли 
исполнение действия. 

```
yes := true
no := false

remArg("walk")
affExpr("walk", "yes|no", 0)
:tag walk;
walk(false)
```
В приведенном выше коде *remArg()* ищет выражение с тегом «walk(идти)» 
и удаляет его аргумент. Это происходит для того, чтобы система 
определила аргументы, которые могут быть отправлены устройству, 
управляющему выражениями. Затем, *affExpr()* сообщает CX: «из всех аргументов, которые могут быть 
отправлены по *walk*, сообщи мне могут ли быть использованы *yes* или *nо* 
в качестве аргументов, и применены как *0-й* вариант из списка возможных вариантов».

Данная процедура применима ко всем действиям, которые могут произойти 
с путешественником. В соответствии со следующими правилами, 
для каждого из этих действий отправляется запрос на 
разрешение их выполнения:

```
setClauses("
          aff(walk, yes, X, R) :- X = monster, R = false.
          aff(noise, yes, X, R) :- X = monster, R = false.

          aff(consider, yes, X, R) :- R = false.
          aff(chance, yes, X, R) :- R = false.
          aff(fightResult, yes, X, R) :- R = false.
          aff(theEnd, yes, X, R) :- R = false.

          aff(consider, yes, X, R) :- X = monster, R = true.
          aff(chance, yes, X, R) :- X = fight, R = true.
          aff(fightResult, yes, X, R) :- X = fight, R = true.
          aff(theEnd, yes, X, R) :- X = died, R = true.
        ")
```
Первое правило будет таким: «Мне придет запрос, на подтверждение 
аргумента *yes* для действия *walk*. Если объект- 
*монстр*, сейчас находится здесь, значит есть дополнительный вариант *not*».

Правила второго блока (4 правила после первой пустой строки) 
говорят системе «никогда» не принимать *yes* аргумент. 
Мы хотим, чтобы это стало поведением по умолчанию, но 
позже мы вполне сможем ввести правила, которые будут переопределять это поведение. 
Процесс переопределения осуществляется последними 4 правилами. В целом, этот блок 
правил дает CX команду принять *yes* в качестве аргумента, при условии, что 
конкретный объект присутствует в стеке объектов.

# Объекты

Некоторые действия могут добавлять либо убирать объект из стека объектов. 
Например, где бы ни появлялось действие *noise*(шум), там появляется монстр, 
исполняется: *addObject(“monster”)*. Когда путешественник принимает решение бежать, 
а не драться, "монстр" как объект исчезает из стека объектов.

В случае выбора действия *chance*(шанс), монстр может дать 
путешественнику несколько секунд на раздумья, чтобы посмотреть, что он будет делать дальше. 
Чтобы воплотить это, необходимо убрать объект “fight” (бой) так как монстр еще не хочет начинать драться, 
но оставить объект "monster".

# Заключение

CX’s affordance system использует объекты и правила, чтобы принимать комплексные 
решения о том, как будет производиться фильтрация.

Используя объекты, мы можем решать какие из действий активировать. 
В этом примере мы рассмотрели небольшое количество действий, 
необходимых для процесса активации. На первый взгляд может показаться, 
что данная архитектура бесполезна. Тем не менее, 
можно установить более сложные правила, включающие в себя большее количество объектов. 
Одно правило может отвечать за активацию нескольких узлов в большой сети 
действий. В примере мы рассмотрели всего два аргумента *yes* и *no*; Мы можем ввести больше аргументов, 
а также действия, которые принимают разные типы аргументов, отличные от булевских значений.
